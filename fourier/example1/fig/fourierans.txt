NIL
/* Starts dribbling to /sattchgithub.io/fourier/example1/fig/fourierans.txt (2019/8/14, 09:58:28).*/
(%i3) powerdisp:false
(%i4) display2d:false
(%i5) linel:1000
(%i6) batch("/Applications/kettex/texlive/texmf-dist/scripts/ketcindy/ketlib/maximaL/pdefourier.mac")

read and interpret file: /Applications/kettex/texlive/texmf-dist/scripts/ketcindy/ketlib/maximaL/pdefourier.mac
(%i7) load(fourie)
(%i8) load(simplify_sum)
(%i9) load(draw)
(%i10) matchdeclare(constn,constantp)
(%i11) defrule(leq,constn >= xx,xx <= constn)
(%i12) defrule(geq,xx >= constn,constn <= xx)
(%i13) defrule(lss,constn > xx,xx < constn)
(%i14) defrule(grtr,xx > constn,constn < xx)
(%i15) fun_parts(expr,var):=block([subint,subval,tmp,ll,tmp1,tmp2,xx,ans,tmp3,tmpb,leftU,rightU],
                 if not piecewisep(expr) then error("The function is not piecewise defined")
                     else (xx:var,ll:(length(expr)-2)/2,tmp:makelist(inpart(expr,i),i,makelist(2*k-1,k,1,ll)),subval:makelist(inpart(expr,i),i,makelist(2*k,k,1,ll)),tmp1:makelist(operatorp(tmp[j],["<",">","<=",">="]),j,1,ll),tmp2:sublist_indices(tmp1,lambda([x],x = true)),
                           if emptyp(tmp2) then (tmp:makelist(makelist(inpart(tmp[k],i),i,1,2),k,1,ll),tmp:apply1(tmp,leq,geq,lss,grtr),subint:makelist(makelist(inpart(tmp[i][j],j),j,1,2),i,1,ll),tmp3:map(lambda([L],lfreeof(L,var)),subint),if not emptyp(sublist_indices(tmp3,lambda([x],x = false))) then error("Check function definition, some interval(s) appear to be empty or ill-defined. Read documentation for further details.") else (ans:makelist([subint[k],subval[k]],k,1,ll),return(ans)))
                               else (if not is(tmp2 = [1,ll]) then error("Check function definition, some interval(s) appear to be empty or ill-defined. Read documentation for further details.")
                                         else (if is(ll = 2) then (tmp:apply1(tmp,leq,geq,lss,grtr),leftU:[[minf,inpart(tmp[1],2)],subval[1]],rightU:[[inpart(tmp[2],1),inf],subval[2]],ans:[leftU,rightU],return(ans)) elseif is(ll > 2) then (leftU:apply1(tmp[1],leq,geq,lss,grtr),rightU:apply1(tmp[ll],leq,geq,lss,grtr),leftU:[[minf,inpart(leftU,2)],subval[1]],rightU:[[inpart(rightU,1),inf],subval[ll]],tmpb:makelist(makelist(inpart(tmp[k],i),i,1,2),k,2,ll-1),tmpb:apply1(tmpb,leq,geq,lss,grtr),subint:makelist(makelist(inpart(tmpb[i][j],j),j,1,2),i,1,ll-2),tmp3:map(lambda([L],lfreeof(L,var)),subint),if not emptyp(sublist_indices(tmp3,lambda([x],x = false))) then error("Check function definition, some interval(s) appear to be empty or ill-defined. Read documentation for further details.") else (ans:append([leftU],makelist([subint[k],subval[k+1]],k,1,ll-2),[rightU]),return(ans)))))))
(%i16) bint_comp(L1,L2,var):=block(if is(L1[1][1] = -L2[1][2]) and is(L1[1][2] = -L2[1][1]) then (if is(L1[2] = 0) and is(L2[2] = 0) then return('zero) elseif equalp(L1[2],ratsubst(-var,var,L2[2])) then return('even) elseif equalp(L1[2],-ratsubst(-var,var,L2[2])) then return('odd) else return('none)) else return('none))
(%i17) uint_comp(L1,L2,var):=block(if is(L1[1][2] = -L2[1][1]) then (if is(L1[2] = 0) and is(L2[2] = 0) then return('zero) elseif equalp(L1[2],ratsubst(-var,var,L2[2])) then return('even) elseif equalp(L1[2],-ratsubst(-var,var,L2[2])) then return('odd) else return('none)) else return('none))
(%i18) parityb(L,var):=block([ll,icentral,aux,ans,llaux,Laux,paux],ll:length(L),
               if is(ll = 1) and is(L[1][1][1] = -L[1][1][2]) then (if evenfunp(L[1][2],var) then return('even) elseif oddfunp(L[1][2],var) then return('odd) else return('none)) elseif is(ll > 1)
                   then (icentral:0,for i thru ll do if is(L[i][1][1]*L[i][1][2] < 0) then icentral:i,
                         if is(icentral = 0) then (if not evenp(ll) then return('none) else (aux:makelist(bint_comp(L[i],L[ll+1-i],var),i,1,ll/2),if is(length(sublist_indices(aux,lambda([x],x = even or x = zero))) = ll/2) then return('even) elseif is(length(sublist_indices(aux,lambda([x],x = odd or x = zero))) = ll/2) then return('odd) else return('none))) elseif is(icentral > 0) and oddp(ll) then (if is(L[icentral][1][1] = -L[icentral][1][2]) then (if evenfunp(L[icentral][2],var) then paux:'even elseif oddfunp(L[icentral][2],var) then paux:'odd else return('none),Laux:delete(L[icentral],L),aux:makelist(bint_comp(Laux[i],Laux[ll-i],var),i,1,(ll-1)/2),if is(length(sublist_indices(aux,lambda([x],x = even or x = zero))) = (ll-1)/2) and is(paux = even) then return('even) elseif is(length(sublist_indices(aux,lambda([x],x = odd or x = zero))) = (ll-1)/2) and is(paux = odd) then return('odd) else return('none)) else return('none))))
(%i19) parityL(L,var):=block([aux1,aux2,Laux,ll],ll:length(L),if not boundedp(L) and is(ll = 2) then (if is(uint_comp(L[1],L[2],var) = zero) or is(uint_comp(L[1],L[2],var) = even) then return('even) elseif is(uint_comp(L[1],L[2],var) = odd) then return('odd) else return('none)) elseif not boundedp(L) and is(ll > 2) then (aux1:uint_comp(L[1],L[ll],var),Laux:delete(L[1],L),Laux:delete(L[ll],Laux),aux2:parityb(Laux,var),if is(aux1 = zero) and is(aux2 = even) or is(aux1 = even) and is(aux2 = even) then return('even) elseif is(aux1 = zero) and is(aux2 = odd) or is(aux1 = odd) and is(aux2 = odd) then return('odd) else return('none)) else return(parityb(L,var)))
(%i20) boundedp(L):=block([ll],ll:length(L),if is(L[1][1][1] = minf) and is(L[ll][1][2] = inf) then return(false) else return(true))
(%i21) piecewisep(expr):=if atom(expr) then false else is(inpart(expr,0) = "if")
(%i22) paritycheck(expr,var):=block(if piecewisep(expr) then return(parityL(fun_parts(expr,var),var)) elseif listp(expr) then return(parityL(expr,var)) else (if equalp(ratsubst(-var,var,expr),expr) then return('even) elseif equalp(ratsubst(-var,var,expr),-expr) then return('odd) else return('none)))
(%i23) symbintp(L):=if boundedp(L) and is(L[1][1][1] = -L[length(L)][1][2]) then L[length(L)][1][2]
(%i24) integratepw(L,var):=block([ll],ll:length(L),return(sum(integrate(L[i][2],var,L[i][1][1],L[i][1][2]),i,1,ll)))
(%i25) sum2list(expr):=if is(expr = 0) then [0] elseif is(nterms(expr) = 1) then [expr] else args(expr)
(%i26) secsum2bl(L):=block([ll,laux],ll:length(L),laux:makelist(i,i,1,ll),create_list([L[i][1],y],i,laux,y,sum2list(L[i][2])))
(%i27) matchdeclare(nexp,lambda([e],e # 0 and nonnegintegerp(e)))
(%i28) matchdeclare(nfreq,lambda([e],e # 0 and nonnegintegerp(e)))
(%i29) matchdeclare(const,lambda([e],e # 0 and freeof(xargument,e)))
(%i30) defmatch(powxsin,const*xargument^nexp*sin((nfreq*%pi*xargument)/pargument),xargument,pargument)
(%i31) defmatch(powxcos,const*xargument^nexp*cos((nfreq*%pi*xargument)/pargument),xargument,pargument)
(%i32) defmatch(multsin,const*sin((nfreq*%pi*xargument)/pargument),xargument,pargument)
(%i33) defmatch(multcos,const*cos((nfreq*%pi*xargument)/pargument),xargument,pargument)
(%i34) powxcos_int(pow,freq,p,a,b):=block(if is(freq = 0) then (b^(pow+1)-a^(pow+1))/(pow+1) elseif is(pow = 0) then (p/(%pi*freq))*(sin((freq*%pi*b)/p)-sin((freq*%pi*a)/p)) elseif is(pow > 0) then (p/(%pi*freq))*(b^pow*sin((freq*%pi*b)/p)-a^pow*sin((freq*%pi*a)/p))-((p*pow)/(freq*%pi))*powxsin_int(pow-1,freq,p,a,b))
(%i35) powxsin_int(pow,freq,p,a,b):=block(if is(freq = 0) then 0 elseif is(pow = 0) then (p/(%pi*freq))*(cos((freq*%pi*a)/p)-cos((freq*%pi*b)/p)) elseif is(pow > 0) then (p/(%pi*freq))*(a^pow*cos((freq*%pi*a)/p)-b^pow*cos((freq*%pi*b)/p))+((p*pow)/(freq*%pi))*powxcos_int(pow-1,freq,p,a,b))
(%i36) heuristic_an(expr,var,p,a,b):=block([n,ans],declare(n,integer),if listp(powxsin(expr,var,p)) then (if is(a = -b) and evenp(nexp) then 0 else (ans:(const/(2*p))*powxsin_int(nexp,nfreq+n,p,a,b)+ev((const/(2*p))*powxsin_int(nexp,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans)) elseif listp(powxcos(expr,var,p)) then (if is(a = -b) and oddp(nexp) then 0 else (ans:(const/(2*p))*powxcos_int(nexp,nfreq+n,p,a,b)+ev((const/(2*p))*powxcos_int(nexp,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans)) elseif listp(multsin(expr,var,p)) then (if is(a = -b) then 0 else (ans:(const/(2*p))*powxsin_int(0,nfreq+n,p,a,b)+ev((const/(2*p))*powxsin_int(0,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans)) elseif listp(multcos(expr,var,p)) then (ans:(const/(2*p))*powxcos_int(0,nfreq+n,p,a,b)+ev((const/(2*p))*powxcos_int(0,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans) else (ans:adefint(expr*cos((n*%pi*var)/p),var,a,b)/p,remove(n,integer),ans))
(%i37) heuristic_bn(expr,var,p,a,b):=block([n,ans],declare(n,integer),if listp(powxsin(expr,var,p)) then (if is(a = -b) and oddp(nexp) then 0 else (ans:((-const)/(2*p))*powxcos_int(nexp,nfreq+n,p,a,b)+ev((const/(2*p))*powxcos_int(nexp,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans)) elseif listp(powxcos(expr,var,p)) then (if is(a = -b) and evenp(nexp) then 0 else (ans:(const/(2*p))*powxsin_int(nexp,nfreq+n,p,a,b)+ev((const/(2*p))*powxsin_int(nexp,n-nfreq,p,a,b),noeval,n),remove(n,integer),ans)) elseif listp(multsin(expr,var,p)) then (ans:((-const)/(2*p))*powxcos_int(0,nfreq+n,p,a,b)+ev((const/(2*p))*powxcos_int(0,nfreq-n,p,a,b),noeval,n),remove(n,integer),ans) elseif listp(multcos(expr,var,p)) then (if is(a = -b) then 0 else (ans:(const/(2*p))*powxsin_int(0,nfreq+n,p,a,b)+ev((const/(2*p))*powxsin_int(0,n-nfreq,p,a,b),noeval,n),remove(n,integer),ans)) else (ans:adefint(expr*sin((n*%pi*var)/p),var,a,b)/p,remove(n,integer),ans))
(%i38) foucoeffpw(L,var):=block([llaux,ll,a0,an,bn,answ,lm],ll:length(L),lm:(L[ll][1][2]-L[1][1][1])/2,Laux:secsum2bl(L),llaux:length(Laux),if is(parityL(L,var) = odd) then (a0:0,an:0,bn:sum(heuristic_bn(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),answ:[a0,an,simplify_sum(bn)],return(ratsimp(answ))) elseif is(parityL(L,var) = even) then (a0:(1/(2*lm))*integratepw(L,var),an:sum(heuristic_an(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),bn:0,answ:[simplify_sum(a0),simplify_sum(an),bn],return(ratsimp(answ))) else (a0:(1/(2*lm))*integratepw(L,var),an:sum(heuristic_an(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),bn:sum(heuristic_bn(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),answ:[a0,an,bn],answ:map(simplify_sum,answ),return(ratsimp(answ))))
(%i39) foucoeffterm(term,var,p):=block([a0,bn,an,ans],if listp(term) then return(foucoeffpw(term,var)) elseif piecewisep(term) then (if is(boundedp(fun_parts(term,var))) then return(foucoeffpw(map(lambda([e],[e[1],expand(trigrat(e[2]))]),fun_parts(term,var)),var)) else error("Domain of the piecewise function is not valid. Read the documentation for further details")) else (if is(paritycheck(term,var) = even) then (a0:ratsimp((1/(2*p))*adefint(term,var,-p,p)),an:heuristic_an(term,var,p,-p,p),bn:0,ans:ratsimp([a0,an,bn]),return(ans)) elseif is(paritycheck(term,var) = odd) then (a0:0,an:0,bn:heuristic_bn(term,var,p,-p,p),ans:ratsimp([a0,an,bn]),return(ans)) else (a0:ratsimp((1/(2*p))*adefint(term,var,-p,p)),an:heuristic_an(term,var,p,-p,p),bn:heuristic_bn(term,var,p,-p,p),ans:ratsimp([a0,an,bn]),return(ans))))
(%i40) list2bl(L):=block([ll,laux],ll:length(L),laux:makelist(i,i,1,ll),create_list(y,i,laux,y,sum2list(L[i])))
(%i41) trigpattern(term,var,p):=block(if listp(powxsin(term,var,p)) then return(nfreq) elseif listp(powxcos(term,var,p)) then return(nfreq) elseif listp(multcos(term,var,p)) then return(nfreq) elseif listp(multsin(term,var,p)) then return(nfreq) else return(false))
(%i42) searchpoles_term(term,var,p):=block([L,Laux,indx_aux,indx],if listp(term) then (L:secsum2bl(term),indx_aux:map(lambda([e],trigpattern(e[2],var,p)),L),indx:unique(sublist(indx_aux,integerp)),return(indx)) elseif piecewisep(term) then (Laux:map(lambda([e],[e[1],expand(trigrat(e[2]))]),fun_parts(term,var)),L:secsum2bl(Laux),indx_aux:map(lambda([e],trigpattern(e[2],var,p)),L),indx:unique(sublist(indx_aux,integerp)),return(indx)) else (indx_aux:trigpattern(term,var,p),if integerp(indx_aux) then return([indx_aux]) else return([])))
(%i43) searchpoles(expr,var,p):=block([L,Laux,indx],Laux:sum2list(expand(expr)),Laux:map(lambda([e],if not piecewisep(e) then expand(trigrat(e)) else e),Laux),L:list2bl(Laux),indx:apply(append,map(lambda([e],searchpoles_term(e,var,p)),L)),return(unique(indx)))
(%i44) fouriercoeff(expr,var,p):=block([ans,Llist,Laux,coeffpoles,poles,n],Laux:sum2list(expand(expr)),Llist:map(lambda([e],if not piecewisep(e) then expand(trigrat(e)) else e),Laux),Llist:list2bl(Llist),ans:lsum(y,y,map(lambda([e],foucoeffterm(e,var,p)),Llist)),ans:ratsimp(ans),poles:searchpoles(expr,var,p),coeffpoles:makelist(at([i,ans[2],ans[3]],n = i),i,poles),declare(n,integer),coeffpoles:ev(coeffpoles),ans:ev(ans),remove(n,integer),return(ratsimp([ans,coeffpoles])))
(%i45) fouriercoeff_expand(fcoeff,var,p,NN):=block([ans,a0,an,bn,poles,indx_poles,polessum,sl_indx,laux],[[a0,an,bn],poles]:fcoeff,an:ev(an),bn:ev(bn),if emptyp(poles) then (ans:a0+sum(at(an*cos((n*%pi*var)/p)+bn*sin((n*%pi*var)/p),n = n),n,1,NN),return(ans)) else (indx_poles:makelist(poles[i][1],i,1,length(poles)),if is(NN = inf) then (polessum:sum(poles[i][2]*cos((poles[i][1]*%pi*var)/p)+poles[i][3]*sin((poles[i][1]*%pi*var)/p),i,1,length(poles)),ans:a0+polessum+sum(at(an*cos((n*%pi*var)/p)+bn*sin((n*%pi*var)/p),n = n),n,1,inf),if is(an = 0) and is(bn = 0) then return(ans),print("The sum is over \\N -",setify(indx_poles)),return(ans)) else (sl_indx:sublist_indices(indx_poles,lambda([e],is(e <= NN))),polessum:lsum(poles[i][2]*cos((poles[i][1]*%pi*var)/p)+poles[i][3]*sin((poles[i][1]*%pi*var)/p),i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,NN)),setify(indx_poles))),ans:a0+polessum+lsum(at(an*cos((n*%pi*var)/p)+bn*sin((n*%pi*var)/p),n = i),i,laux),return(ans))))
(%i46) fourier_series(expr,var,p,NN):=block([fcoeff,ans],fcoeff:fouriercoeff(expr,var,p),ans:fouriercoeff_expand(fcoeff,var,p,NN),ans)
(%i47) fourier_amplitudes(expr,var,p,N):=block([a0,an,bn,ans,poles,indx_poles,polelist,sl_indx,laux],[[a0,an,bn],poles]:fouriercoeff(expr,var,p),an:ev(an),bn:ev(bn),if emptyp(poles) then (ans:makelist(at([n,sqrt(an^2+bn^2)],n = i),i,1,N),return(ans)) else (indx_poles:makelist(poles[i][1],i,1,length(poles)),sl_indx:sublist_indices(indx_poles,lambda([e],is(e < N))),polelist:makelist([poles[i][1],sqrt(poles[i][2]^2+poles[i][3]^2)],i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,N)),setify(indx_poles))),ans:append(polelist,makelist(at([n,sqrt(an^2+bn^2)],n = i),i,laux)),ans:sort(ans,lambda([a,b],a[1] < b[1])),return(ans)))
(%i48) fourier_freq_list(expr,var,p,N):=block([modules],modules:float(fourier_amplitudes(expr,var,p,N)))
(%i49) fourier_freq(expr,var,p,N):=block([modules],modules:float(fourier_amplitudes(expr,var,p,N)),draw2d(points_joined = impulses,line_width = 4,color = "blue",points(modules),xlabel = "w(n)=nw_0",ylabel = "|c_n|",axis_top = false,axis_right = false,xtics = 1,user_preamble = "set grid ytics"))
(%i50) wxfourier_freq(expr,var,p,N):=block([modules],modules:float(fourier_amplitudes(expr,var,p,N)),wxdraw2d(points_joined = impulses,line_width = 4,color = "blue",points(modules),xlabel = "w(n)=nw_0",ylabel = "|c_n|",axis_top = false,axis_right = false,xtics = 1,user_preamble = "set grid ytics"))
(%i51) atan_fourier(an,bn):=if is(an = 0) and is(bn = 0) then 0 else atan2(an,bn)
(%i52) fourier_phshift(expr,var,p,N):=block([a0,an,bn,ans,poles,indx_poles,polelist,sl_indx,laux],[[a0,an,bn],poles]:fouriercoeff(expr,var,p),an:ev(an),bn:ev(bn),if emptyp(poles) then (ans:makelist([i,atan_fourier(at(bn,n = i),at(an,n = i))],i,1,N),return(ans)) else (indx_poles:makelist(poles[i][1],i,1,length(poles)),sl_indx:sublist_indices(indx_poles,lambda([e],is(e < N))),polelist:makelist([poles[i][1],atan_fourier(poles[i][3],poles[i][2])],i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,N)),setify(indx_poles))),ans:append(polelist,makelist([i,atan_fourier(at(bn,n = i),at(an,n = i))],i,laux)),ans:sort(ans,lambda([a,b],a[1] < b[1])),return(ans)))
(%i53) fourier_harm(expr,var,p,N):=block([amplitudes,phshift,ans],amplitudes:fourier_amplitudes(expr,var,p,N),phshift:fourier_phshift(expr,var,p,N),ans:makelist(amplitudes[i][2]*cos((i*%pi*var)/p-phshift[i][2]),i,1,N),return(ans))
(%i54) chop(expr,[N]):=if emptyp(N) then scanmap(lambda([x],if is(numberp(x)) then (if is(abs(x) < 1.0*10^-12) then 0.0 else x) else x),expr) else scanmap(lambda([x],if is(numberp(x)) then (if is(abs(x) < 1.0*10^-N[1]) then 0.0 else x) else x),expr)
(%i55) oddextension_pwterm(L,var):=block([Laux],Laux:[[-L[1][2],-L[1][1]],-ratsubst(-x,x,L[2])],Laux)
(%i56) oddextensionpw(L,var):=block([Lodd],Lodd:append(reverse(map(lambda([e],oddextension_pwterm(e,var)),L)),L),Lodd)
(%i57) evenextension_pwterm(L,var):=block([Laux],Laux:[[-L[1][2],-L[1][1]],ratsubst(-x,x,L[2])],Laux)
(%i58) evenextensionpw(L,var):=block([Lodd],Lodd:append(reverse(map(lambda([e],evenextension_pwterm(e,var)),L)),L),Lodd)
(%i59) odd_extension(expr,var,p):=block([Laux],if piecewisep(expr) then (Laux:fun_parts(expr,var),if is(Laux[1][1][1] = 0) and is(Laux[length(Laux)][1][2] = p) then return(oddextensionpw(Laux,var)) else error("The domain must be of the form [0,p]")) else (Laux:[[[0,p],expr]],return(oddextensionpw(Laux,var))))
(%i60) even_extension(expr,var,p):=block([Laux],if piecewisep(expr) then (Laux:fun_parts(expr,var),if is(Laux[1][1][1] = 0) and is(Laux[length(Laux)][1][2] = p) then return(evenextensionpw(Laux,var)) else error("The domain must be of the form [0,p]")) else (Laux:[[[0,p],expr]],return(evenextensionpw(Laux,var))))
(%i61) fouriersincoeffpw(Llist,var):=block([llaux,ll,bn,answ,lm],ll:length(Llist),lm:Llist[ll][1][2]-Llist[1][1][1],Laux:secsum2bl(Llist),llaux:length(Laux),bn:2*sum(heuristic_bn(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),answ:[bn],answ:map(simplify_sum,answ),return(ratsimp(answ)))
(%i62) fouriercoscoeffpw(Llist,var):=block([llaux,ll,a0,an,answ,lm],ll:length(Llist),lm:Llist[ll][1][2]-Llist[1][1][1],Laux:secsum2bl(Llist),llaux:length(Laux),a0:(1/lm)*integratepw(Llist,var),an:2*sum(heuristic_an(Laux[i][2],var,lm,Laux[i][1][1],Laux[i][1][2]),i,1,llaux),answ:[a0,an],answ:map(simplify_sum,answ),return(ratsimp(answ)))
(%i63) fouriersincoeffterm(term,var,p):=block([bn,ans],if listp(term) then return(fouriersincoeffpw(term,var)) elseif piecewisep(term) then (if is(boundedp(fun_parts(term,var))) then return(fouriersincoeffpw(map(lambda([e],[e[1],expand(trigrat(e[2]))]),fun_parts(term,var)),var)) else error("Domain of the piecewise function is not valid. Read the documentation for further details")) else (bn:2*heuristic_bn(term,var,p,0,p),ans:ratsimp([bn]),return(ans)))
(%i64) fouriercoscoeffterm(term,var,p):=block([a0,an,ans],if listp(term) then return(fouriercoscoeffpw(term,var)) elseif piecewisep(term) then (if is(boundedp(fun_parts(term,var))) then return(fouriercoscoeffpw(map(lambda([e],[e[1],expand(trigrat(e[2]))]),fun_parts(term,var)),var)) else error("Domain of the piecewise function is not valid. Read the documentation for further details")) else (a0:ratsimp((1/p)*adefint(term,var,0,p)),an:2*heuristic_an(term,var,p,0,p),ans:ratsimp([a0,an]),return(ans)))
(%i65) fouriersincoeff(expr,var,p):=block([ans,Llist,Laux,coeffpoles,poles,n],Laux:sum2list(expand(expr)),Llist:map(lambda([e],if not piecewisep(e) then expand(trigrat(e)) else e),Laux),Llist:list2bl(Llist),ans:lsum(y,y,map(lambda([e],fouriersincoeffterm(e,var,p)),Llist)),ans:ratsimp(ans),poles:searchpoles(expr,var,p),coeffpoles:makelist(at([i,ans[1]],n = i),i,poles),declare(n,integer),coeffpoles:ev(coeffpoles),ans:ev(ans),remove(n,integer),return(ratsimp([ans,coeffpoles])))
(%i66) fouriercoscoeff(expr,var,p):=block([ans,Llist,Laux,coeffpoles,poles,n],Laux:sum2list(expand(expr)),Llist:map(lambda([e],if not piecewisep(e) then expand(trigrat(e)) else e),Laux),Llist:list2bl(Llist),ans:lsum(y,y,map(lambda([e],fouriercoscoeffterm(e,var,p)),Llist)),ans:ratsimp(ans),poles:searchpoles(expr,var,p),coeffpoles:makelist(at([i,ans[2]],n = i),i,poles),declare(n,integer),coeffpoles:ev(coeffpoles),ans:ev(ans),remove(n,integer),return(ratsimp([ans,coeffpoles])))
(%i67) fouriersincoeff_expand(sincoeff,var,p,NN):=block([ans,bn,poles,indx_poles,polessum,sl_indx,laux],[[bn],poles]:sincoeff,bn:ev(bn),if emptyp(poles) then (ans:sum(at(bn*sin((n*%pi*var)/p),n = n),n,1,NN),return(ans)) else (indx_poles:makelist(poles[i][1],i,1,length(poles)),if is(NN = inf) then (polessum:sum(poles[i][2]*sin((poles[i][1]*%pi*var)/p),i,1,length(poles)),ans:polessum+sum(at(bn*sin((n*%pi*var)/p),n = n),n,1,inf),if is(bn = 0) then return(ans),print("The sum is over \\N-",setify(indx_poles)),return(ans)) else (sl_indx:sublist_indices(indx_poles,lambda([e],is(e <= NN))),polessum:lsum(poles[i][2]*sin((poles[i][1]*%pi*var)/p),i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,NN)),setify(indx_poles))),ans:polessum+lsum(at(bn*sin((n*%pi*var)/p),n = i),i,laux),return(ans))))
(%i68) fouriercoscoeff_expand(coscoeff,var,p,NN):=block([ans,a0,an,poles,indx_poles,polessum,sl_indx,laux],[[a0,an],poles]:coscoeff,an:ev(an),if emptyp(poles) then (ans:a0+sum(at(an*cos((n*%pi*var)/p),n = n),n,1,NN),return(ans)) else (indx_poles:makelist(poles[i][1],i,1,length(poles)),if is(NN = inf) then (polessum:sum(poles[i][2]*cos((poles[i][1]*%pi*var)/p),i,1,length(poles)),ans:a0+polessum+sum(at(an*cos((n*%pi*var)/p),n = n),n,1,inf),if is(an = 0) then return(ans),print("The sum is over \\N -",setify(indx_poles)),return(ans)) else (sl_indx:sublist_indices(indx_poles,lambda([e],is(e <= NN))),polessum:lsum(poles[i][2]*cos((poles[i][1]*%pi*var)/p),i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,NN)),setify(indx_poles))),ans:a0+polessum+lsum(at(an*cos((n*%pi*var)/p),n = i),i,laux),return(ans))))
(%i69) fouriersin_series(expr,var,p,NN):=block([ans,sincoeff],sincoeff:fouriersincoeff(expr,var,p),ans:fouriersincoeff_expand(sincoeff,var,p,NN),ans)
(%i70) fouriercos_series(expr,var,p,NN):=block([ans,coscoeff],coscoeff:fouriercoscoeff(expr,var,p),ans:fouriercoscoeff_expand(coscoeff,var,p,NN),ans)
(%i71) real2complex_fcoeff(fcoeff):=block([c0,cn,cpoles,rpoles,a0,an,bn],[[a0,an,bn],rpoles]:fcoeff,c0:a0,cn:(an-%i*bn)/2,cpoles:map(lambda([e],[e[1],(e[2]-%i*e[3])/2]),rpoles),ratsimp([[c0,cn],cpoles]))
(%i72) cfouriercoeff(expr,var,p):=real2complex_fcoeff(fouriercoeff(expr,var,p))
(%i73) cfouriercoeff_expand(cfcoeff,var,p,NN):=block([ans,c0,cn,cpoles,indx_cpoles,cpolessumpos,cpolessumneg,sl_indx,laux],[[c0,cn],cpoles]:cfcoeff,an:ev(cn),
                            if emptyp(cpoles) then (if is(NN = inf) then (ans:c0+sum(at(cn*exp((%i*n*%pi*var)/p),n = n),n,minf,inf),print("The sum is over \\N-{0}"),return(ans)) else (ans:c0+sum(at(conjugate(cn)*exp((%i*(-n)*%pi*var)/p),n = n),n,1,NN)+sum(at(cn*exp((%i*n*%pi*var)/p),n = n),n,1,NN),return(ratsimp(demoivre(ans)))))
                                else (indx_cpoles:map(first,cpoles),if is(NN = inf) then (cpolessumpos:sum(cpoles[i][2]*exp((%i*cpoles[i][1]*%pi*var)/p),i,1,length(cpoles)),cpolessumneg:sum(conjugate(cpoles[i][2])*exp(((-%i)*cpoles[i][1]*%pi*var)/p),i,1,length(cpoles)),ans:c0+cpolessumpos+cpolessumneg+sum(at(cn*exp((%i*n*%pi*var)/p),n = n),n,minf,inf),if is(cn = 0) then return(ans),print("The sum is over \\N -",setify(append(indx_cpoles,[0]))),return(ans)) else (sl_indx:sublist_indices(indx_cpoles,lambda([e],is(e <= NN))),cpolessumpos:lsum(cpoles[i][2]*exp((%i*cpoles[i][1]*%pi*var)/p),i,sl_indx),cpolessumneg:lsum(conjugate(cpoles[i][2])*exp(((-%i)*cpoles[i][1]*%pi*var)/p),i,sl_indx),laux:listify(setdifference(setify(makelist(i,i,1,NN)),setify(indx_cpoles))),ans:c0+cpolessumpos+cpolessumneg+lsum(at(cn*exp((%i*n*%pi*var)/p),n = i),i,laux)+lsum(at(conjugate(cn)*exp(((-%i)*n*%pi*var)/p),n = i),i,laux),return(ratsimp(demoivre(ans))))))
(%i74) cfourier_series(expr,var,p,NN):=cfouriercoeff_expand(cfouriercoeff(expr,var,p),var,p,NN)
(%i75) evalpole_scn(bfn,polesf,indx_pf,indx):=block([n],if member(indx,indx_pf) then return(assoc(indx,polesf)) else return(at(bfn,n = indx)))
(%i76) fourier_heatcoeff(Qexpr,fexpr,var,p,kap):=block([bnf,bnQ,polesf,polesQ,indxpf,indxpQ,indxp,n,un,polesU,ans],[[bnf],polesf]:fouriersincoeff(fexpr,var,p),[[bnQ],polesQ]:fouriersincoeff(Qexpr,var,p),declare(n,integer),un:bnf*exp((-((n*%pi)/p)^2)*kap*t)+integrate(at(bnQ,t = s)*exp((-((n*%pi)/p)^2)*kap*(t-s)),s,0,t),if emptyp(polesf) and emptyp(polesQ) then (ans:[[un],[]],remove(n,integer),return(ratsimp(ans))) else (indxpf:map(first,polesf),indxpQ:map(first,polesQ),indxp:unique(append(indxpf,indxpQ)),polesU:map(lambda([e],[e,evalpole_scn(bnf,polesf,indxpf,e)*exp((-((e*%pi)/p)^2)*kap*t)+integrate(at(evalpole_scn(bnQ,polesQ,indxpQ,e),t = s)*exp((-((e*%pi)/p)^2)*kap*(t-s)),s,0,t)]),indxp),ans:[[un],polesU],remove(n,integer),return(ratsimp(ans))))
(%i77) fourier_heat(Qexpr,fexpr,var,p,kap,NN):=fouriersincoeff_expand(fourier_heatcoeff(Qexpr,fexpr,var,p,kap),var,p,NN)
(%i78) fourier_wavecoeff(Qexpr,fexpr,gexpr,var,p,A):=block([indxp,indxpf,indxpQ,indxpg,n,polesf,polesg,polesQ,bnf,bnQ,bng,Ln,un,polesU],Ln:(n*%pi*A)/p,[[bnf],polesf]:fouriersincoeff(fexpr,var,p),[[bng],polesg]:fouriersincoeff(gexpr,var,p),[[bnQ],polesQ]:fouriersincoeff(Qexpr,var,p),bng:bng/Ln,polesg:map(lambda([e],[e[1],e[2]*at(1/Ln,n = e[1])]),polesg),declare(n,integer),un:bnf*cos(Ln*t)+bng*sin(Ln*t)+(1/Ln)*integrate(at(bnQ,t = s)*sin(Ln*(t-s)),s,0,t),if emptyp(polesf) and emptyp(polesQ) and emptyp(polesg) then (ans:[[un],[]],remove(n,integer),return(ratsimp(ans))) else (indxpf:map(first,polesf),indxpQ:map(first,polesQ),indxpg:map(first,polesg),indxp:unique(append(indxpf,indxpQ,indxpg)),polesU:map(lambda([e],[e,evalpole_scn(bnf,polesf,indxpf,e)*cos((e*%pi*A*t)/p)+evalpole_scn(bng,polesg,indxpg,e)*sin((e*%pi*A*t)/p)+(p/(e*%pi*A))*integrate(at(evalpole_scn(bnQ,polesQ,indxpQ,e),t = s)*sin((e*%pi*A*(t-s))/p),s,0,t)]),indxp),ans:[[un],polesU],remove(n,integer),return(ratsimp(ans))))
(%i79) fourier_wave(Qexpr,fexpr,gexpr,var,p,A,NN):=fouriersincoeff_expand(fourier_wavecoeff(Qexpr,fexpr,gexpr,var,p,A),var,p,NN)
(%i80) dirichlet_heat(Qexpr,fexpr,h1expr,h2expr,var,p,kap,NN):=block([Qaux,faux,vaux],vaux:((h1expr-h2expr)*var)/p-h1expr,Qaux:Qexpr+diff(vaux,t),faux:fexpr+at(vaux,t = 0),fourier_heat(Qaux,faux,var,p,kap,NN)-vaux)
(%i81) dirichlet_wave(Qexpr,fexpr,gexpr,h1expr,h2expr,var,p,A,NN):=block([Qaux,faux,gaux,vaux],vaux:((h1expr-h2expr)*var)/p-h1expr,Qaux:Qexpr+diff(vaux,t,2),faux:fexpr+at(vaux,t = 0),gaux:gexpr+at(diff(vaux,t),t = 0),fourier_wave(Qaux,faux,gaux,var,p,A,NN)-vaux)
(%i82) dirichlet_laplace_disk(a,fexpr,var,NN):=block([cn,c0,cpoles,n],[[c0,cn],cpoles]:cfouriercoeff(fexpr,var,%pi),cn:(r/a)^abs(n)*cn,cpoles:map(lambda([e],[e[1],(r/a)^e[1]*e[2]]),cpoles),cfouriercoeff_expand([[c0,cn],cpoles],var,%pi,NN))
(%i83) neumann_laplace_disk(a,fexpr,var,NN):=block([a0,an,bn,poles,n],[[a0,an,bn],poles]:fouriercoeff(fexpr,var,%pi),if not is(a0 = 0) then return("The solution does not exist.") else (an:(a/n)*an*(r/a)^n,bn:(a/n)*bn*(r/a)^n,poles:map(lambda([e],[e[1],e[2]*(a/e[1])*(r/a)^e[1],e[3]*(a/e[1])*(r/a)^e[1]]),poles),return(fouriercoeff_expand([[a0,an,bn],poles],var,%pi,NN))))
(%i84) dirichlet_laplace_annulus(a,b,fexpr,gexpr,var,NN):=block([n,cnf,c0f,cng,c0g,cpolesf,cpolesg,c0aux,cnaux,cpolesaux,indxpf,indxpg,indxp,ans],[[c0f,cnf],cpolesf]:cfouriercoeff(fexpr,var,%pi),[[c0g,cng],cpolesg]:cfouriercoeff(gexpr,var,%pi),c0aux:(c0g*log(b)-c0f*log(a))*log(b/a)+((c0f-c0g)*log(r))/log(b/a),cnaux:((b^abs(n)*r^abs(n)-a^abs(2*n)*b^abs(n)*r^-abs(n))*cnf)/(b^abs(2*n)-a^abs(2*n))+(cng*(b^abs(2*n)*a^abs(n)*r^-abs(n)-a^abs(n)*r^abs(n)))/(b^abs(2*n)-a^abs(2*n)),if emptyp(cpolesf) and emptyp(cpolesg) then (ans:cfouriercoeff_expand(ratsimp([[c0aux,cnaux],[]]),var,%pi,NN),return(ans)) else (indxpf:map(first,cpolesf),indxpg:map(first,cpolesg),indxp:unique(append(indxpf,indxpg)),cpolesaux:map(lambda([e],[e,((b^e*r^e-a^(2*e)*b^e*r^-e)*evalpole_scn(cnf,cpolesf,indxpf,e))/(b^(2*e)-a^(2*e))+(evalpole_scn(cng,cpolesg,indxpg,e)*(b^(2*e)*a^e*r^-e-a^e*r^e))/(b^(2*e)-a^(2*e))]),indxp),ans:cfouriercoeff_expand(ratsimp([[c0aux,cnaux],cpolesaux]),var,%pi,NN),return(ans)))
(%i85) dirichlet_laplace_wedge(R,a,fexpr,var,NN):=block([bnf,polesf,bnaux,polesaux,n,p:a],[[bnf],polesf]:fouriersincoeff(fexpr,var,p),bnaux:bnf*(r/R)^((n*%pi)/a),if emptyp(polesf) then return(fouriersincoeff_expand([[bnaux],[]],var,p,NN)) else (polesaux:map(lambda([e],[e[1],e[2]*(r/R)^((e[1]*%pi)/a)]),polesf),return(fouriersincoeff_expand([[bnaux],polesaux],var,p,NN))))
(%i86) neumann_laplace_wedge(R,a,fexpr,var,NN):=block([bnf,polesf,bnaux,polesaux,n,p:a],[[bnf],polesf]:fouriersincoeff(fexpr,var,p),bnaux:bnf*(r/R)^((n*%pi)/a)*((R*a)/(n*%pi)),if emptyp(polesf) then return(fouriersincoeff_expand([[bnaux],[]],var,p,NN)) else (polesaux:map(lambda([e],[e[1],e[2]*(r/R)^((e[1]*%pi)/a)*((R*a)/(e[1]*%pi))]),polesf),return(fouriersincoeff_expand([[bnaux],polesaux],var,p,NN))))
(%i87) dirichlet_laplace_rectangle(a,b,f1expr,f2expr,g1expr,g2expr,var1,var2,NN):=block([n,f1n,polesf1,f2n,polesf2,g1n,polesg1,g2n,polesg2,indxpf1,indxpf2,indxpg1,indxpg2,indxp,Fnaux,Gnaux,polesFaux,polesGaux,ans],[[f1n],polesf1]:fouriersincoeff(f1expr,var1,a),[[f2n],polesf2]:fouriersincoeff(f2expr,var1,a),[[g1n],polesg1]:fouriersincoeff(g1expr,var2,b),[[g2n],polesg2]:fouriersincoeff(g2expr,var2,b),Fnaux:(f1n*sinh((n*%pi*(b-var2))/a))/sinh((n*%pi*b)/a)+(f2n*sinh((n*%pi*var2)/a))/sinh((n*%pi*b)/a),Gnaux:(g1n*sinh((n*%pi*(a-var1))/b))/sinh((n*%pi*a)/b)+(g2n*sinh((n*%pi*var1)/b))/sinh((n*%pi*a)/b),
                                   if emptyp(polesf1) and emptyp(polesf2) and emptyp(polesg1) and emptyp(polesg2) then (ans:fouriersincoeff_expand([[Fnaux],[]],var1,a,NN)+fouriersincoeff_expand([[Gnaux],[]],var2,b,NN),return(ans)) else (indxpf1:map(first,polesf1),indxpf2:map(first,polesf2),indxpg1:map(first,polesg1),indxpg2:map(first,polesg2),indxp:unique(append(indxpf1,indxpf2,indxpg1,indxpg2)),polesFaux:map(lambda([e],[e,(evalpole_scn(f1n,polesf1,indxpf1,e)*sinh((e*%pi*(b-var2))/a))/sinh((e*%pi*b)/a)+(evalpole_scn(f2n,polesf2,indxpf2,e)*sinh((e*%pi*var2)/a))/sinh((e*%pi*b)/a)]),indxp),polesGaux:map(lambda([e],[e,(evalpole_scn(g1n,polesg1,indxpg1,e)*sinh((e*%pi*(a-var1))/b))/sinh((e*%pi*a)/b)+(evalpole_scn(g2n,polesg2,indxpg2,e)*sinh((e*%pi*var1)/b))/sinh((e*%pi*a)/b)]),indxp),ans:fouriersincoeff_expand([[Fnaux],polesFaux],var1,a,NN)+fouriersincoeff_expand([[Gnaux],polesGaux],var2,b,NN),return(ans)))
(%i88) neumann_laplace_rectangle(a,b,f1expr,f2expr,g1expr,g2expr,var1,var2,NN):=block([n,f1n,polesf1,f2n,polesf2,g1n,polesg1,g2n,polesg2,indxpf1,indxpf2,indxpg1,indxpg2,indxp,Fnaux,Gnaux,polesFaux,polesGaux,C,ans,f10,g10,f20,g20],[[f10,f1n],polesf1]:fouriercoscoeff(f1expr,var1,a),[[f20,f2n],polesf2]:fouriercoscoeff(f2expr,var1,a),[[g10,g1n],polesg1]:fouriercoscoeff(g1expr,var2,b),[[g20,g2n],polesg2]:fouriercoscoeff(g2expr,var2,b),Fnaux:(((-a)/(n*%pi))*f1n*cosh((n*%pi*(b-var2))/a))/sinh((n*%pi*b)/a)+((a/(n*%pi))*f2n*cosh((n*%pi*var2)/a))/sinh((n*%pi*b)/a),Gnaux:(((-b)/(n*%pi))*g1n*cosh((n*%pi*(a-var1))/b))/sinh((n*%pi*a)/b)+((b/(n*%pi))*g2n*cosh((n*%pi*var1)/b))/sinh((n*%pi*a)/b),
                                 if emptyp(polesf1) and emptyp(polesf2) and emptyp(polesg1) and emptyp(polesg2) then (ans:fouriercoscoeff_expand([[0,Fnaux],[]],var1,a,NN)+fouriercoscoeff_expand([[0,Gnaux],[]],var2,b,NN),return(ans+C)) else (indxpf1:map(first,polesf1),indxpf2:map(first,polesf2),indxpg1:map(first,polesg1),indxpg2:map(first,polesg2),indxp:unique(append(indxpf1,indxpf2,indxpg1,indxpg2)),polesFaux:map(lambda([e],[e,(((-a)/(n*%pi))*evalpole_scn(f1n,polesf1,indxpf1,e)*cosh((e*%pi*(b-var2))/a))/sinh((e*%pi*b)/a)+((a/(n*%pi))*evalpole_scn(f2n,polesf2,indxpf2,e)*cosh((e*%pi*var2)/a))/sinh((e*%pi*b)/a)]),indxp),polesGaux:map(lambda([e],[e,(((-b)/(n*%pi))*evalpole_scn(g1n,polesg1,indxpg1,e)*cosh((e*%pi*(a-var1))/b))/sinh((e*%pi*a)/b)+((b/(n*%pi))*evalpole_scn(g2n,polesg2,indxpg2,e)*cosh((e*%pi*var1)/b))/sinh((e*%pi*a)/b)]),indxp),ans:fouriercoscoeff_expand([[0,Fnaux],polesFaux],var1,a,NN)+fouriercoscoeff_expand([[0,Gnaux],polesGaux],var2,b,NN),return(ans+C)))
(%i89) BesselJZeros(m,k,[u]):=block([a,alpha,A,answ],local(a,alpha,A),if is(not m > -1) then return("The order m must be m>-1"),if is(not integerp(k)) or is(not k > 0) then return("k must be an integer k>0"),a[i]:=m+2*i,alpha[i,j]:=if is(equal(i,j)) then 2/((a[i]-1)*(a[i]+1)) elseif is(equal(j,i-1)) then 1/((a[i]-1)*sqrt((a[i]-2)*a[i])) elseif is(equal(j,i+1)) then 1/((a[i+1]-1)*sqrt((a[i+1]-2)*a[i+1])) else 0,A:genmatrix(alpha,ceiling(k/0.64)+10,ceiling(k/0.64)+10),answ:2/sqrt(first(eigens_by_jacobi(A,floatfield))),if is(not equal(length(u),0)) and is(equal(first(u),all)) then firstn(sort(answ),k) elseif is(not equal(length(u),0)) and is(not equal(first(u),all)) then return("Do you want the first k roots? In this case, the option is 'all'") else last(firstn(sort(answ),k)))
(%i90) simpgen(l1,l2):=append(endcons(last(l1)+first(l2),rest(l1,-1)),rest(l2,1))
(%i91) pairing(L1,L2):=xreduce(append,map(lambda([x],map(lambda([y],[x,y]),L2)),L1))
(%i92) nintegrate(f,m,[I]):=block([n:length(args(lhs(apply(fundef,[f])))),tmp:xreduce(simpgen,makelist([1,4,1],j,1,m/2)),x,deltax,p,w,ww,xx],local(x,deltax,p,w),if is(not evenp(m)) then return("The number of subdivisions m must be even") elseif is(not equal(length(I),n)) then return("The number of variables xi and intervals [ai,bi] must match") else (for i thru n do x[i]:args(lhs(apply(fundef,[f])))[i],for i thru n do deltax[i]:(I[i][2]-I[i][1])/m,for j thru n do p[j]:makelist(I[j][1]+k*deltax[j],k,0,m),for j thru n do w[j]:(deltax[j]/3)*tmp,if is(equal(n,1)) then ww:w[1] else ww:map(lambda([x],apply("*",x)),map(flatten,xreduce(pairing,makelist(w[j],j,1,n)))),if is(equal(n,1)) then xx:p[1] else xx:map(flatten,xreduce(pairing,makelist(p[j],j,1,n))),if is(equal(n,1)) then bfloat(apply("+",ww*map(f,xx))) else bfloat(apply("+",ww*map(lambda([x],apply(f,x)),xx)))))
(%i93) a0(n,a,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)),k:1/(p*a^2*bessel_j(1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i94) a(m,n,a,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)*cos(m*theta)),k:2/(p*a^2*bessel_j(m+1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i95) b(m,n,a,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)*sin(m*theta)),k:2/(p*a^2*bessel_j(m+1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i96) as0(n,a,c,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)),k:1/(c*p*lam*a^2*bessel_j(1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i97) as(m,n,a,c,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)*cos(m*theta)),k:2/(c*p*lam*a^2*bessel_j(m+1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i98) bs(m,n,a,c,f):=block([r:args(lhs(apply(fundef,[f])))[1],theta:args(lhs(apply(fundef,[f])))[2],lam:BesselJZeros(0,n)/a,p:%pi,ff,k],local(ff),define(funmake(ff,[r,theta]),apply(f,[r,theta])*r*bessel_j(0,lam*r)*sin(m*theta)),k:2/(c*p*lam*a^2*bessel_j(m+1,lam)^2),k*nintegrate(ff,14,[0,a],[0,2*p]))
(%i99) wave2d_disk(c,a,f,g,k,l):=block([A0,A,B,As0,As,Bs,lamb],local(A0,A,B,As0,As,Bs,lamb,t),A0[i]:=a0(i,a,f),A[i,j]:=a(i,j,a,f),B[i,j]:=b(i,j,a,f),As0[i]:=as0(i,a,c,g),As[i,j]:=as(i,j,a,c,g),Bs[i,j]:=bs(i,j,a,c,g),lamb[i,j]:=BesselJZeros(i,j)/a,sum(A0[n]*bessel_j(0,lamb[0,n]*r)*cos(c*lamb[0,n]*t),n,1,l)+sum(sum(bessel_j(m,lamb[m,n]*r)*(A[m,n]*cos(m*theta)+B[m,n]*sin(m*theta))*cos(c*lamb[m,n]*t),n,1,l),m,1,k)+sum(As0[n]*bessel_j(0,lamb[0,n]*r)*sin(c*lamb[0,n]*t),n,1,l)+sum(sum(bessel_j(m,lamb[m,n]*r)*(As[m,n]*cos(m*theta)+Bs[m,n]*sin(m*theta))*sin(c*lamb[m,n]*t),n,1,l),m,1,k))
(%i100) Arect(f,a,b,m,n):=block([x:args(lhs(apply(fundef,[f])))[1],y:args(lhs(apply(fundef,[f])))[2]],define(funmake(ff,[x,y]),apply(f,[x,y])*sin((m*%pi*x)/a)*sin((m*%pi*y)/b)),(4*nintegrate(ff,14,[0,a],[0,b]))/(a*b))
(%i101) Brect(g,a,b,c,m,n):=block([x:args(lhs(apply(fundef,[f])))[1],y:args(lhs(apply(fundef,[f])))[2],lamb],local(lamb),lamb[m,n]:=((m/a)^2+(n/b)^2)/%pi^2,define(funmake(gg,[x,y]),apply(g,[x,y])*sin((m*%pi*x)/a)*sin((m*%pi*y)/b)),(4*nintegrate(gg,14,[0,a],[0,b]))/(a*b*c*sqrt(lam[m,n])))
(%i102) wave2d_rectangle(c,a,b,f,g,k,l):=block([x:args(lhs(apply(fundef,[f])))[1],y:args(lhs(apply(fundef,[f])))[2],lamb,t],local(lamb,t),lamb[m,n]:=((m/a)^2+(n/b)^2)/%pi^2,sum(sum((Arect(f,a,b,m,n)*cos(sqrt(lamb[0,n])*c*t)+Brect(g,a,b,c,m,n)*sin(sqrt(lamb[0,n])*c*t))*sin((m*%pi*x)/a)*sin((n*%pi*y)/b),m,1,k),n,1,l))
(%i103) f0(x):=if -2 <= x and x < -1 then -1 elseif -1 <= x and x < 1 then 1 elseif 1 <= x and x < 2 then -1
(%i104) c:fouriercoeff(f0(x),x,4)
(%i105) c:c[1]
(%i106) disp(c[1])
0

(%i107) disp(c[2])
(4*sin((%pi*n)/2))/(%pi*n)

(%i108) disp(c[3])
0

(%i109) closefile()
